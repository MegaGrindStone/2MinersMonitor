// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'reward_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RewardModelTearOff {
  const _$RewardModelTearOff();

  _RewardModel call(
      {required int blockNumber,
      required DateTime time,
      required String blockHash,
      required double reward,
      required double percentage,
      required double personalLuck,
      required bool isImmature,
      required bool isUncle,
      required bool isOrphan,
      required bool isSolo}) {
    return _RewardModel(
      blockNumber: blockNumber,
      time: time,
      blockHash: blockHash,
      reward: reward,
      percentage: percentage,
      personalLuck: personalLuck,
      isImmature: isImmature,
      isUncle: isUncle,
      isOrphan: isOrphan,
      isSolo: isSolo,
    );
  }
}

/// @nodoc
const $RewardModel = _$RewardModelTearOff();

/// @nodoc
mixin _$RewardModel {
  int get blockNumber => throw _privateConstructorUsedError;
  DateTime get time => throw _privateConstructorUsedError;
  String get blockHash => throw _privateConstructorUsedError;
  double get reward => throw _privateConstructorUsedError;
  double get percentage => throw _privateConstructorUsedError;
  double get personalLuck => throw _privateConstructorUsedError;
  bool get isImmature => throw _privateConstructorUsedError;
  bool get isUncle => throw _privateConstructorUsedError;
  bool get isOrphan => throw _privateConstructorUsedError;
  bool get isSolo => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RewardModelCopyWith<RewardModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RewardModelCopyWith<$Res> {
  factory $RewardModelCopyWith(
          RewardModel value, $Res Function(RewardModel) then) =
      _$RewardModelCopyWithImpl<$Res>;
  $Res call(
      {int blockNumber,
      DateTime time,
      String blockHash,
      double reward,
      double percentage,
      double personalLuck,
      bool isImmature,
      bool isUncle,
      bool isOrphan,
      bool isSolo});
}

/// @nodoc
class _$RewardModelCopyWithImpl<$Res> implements $RewardModelCopyWith<$Res> {
  _$RewardModelCopyWithImpl(this._value, this._then);

  final RewardModel _value;
  // ignore: unused_field
  final $Res Function(RewardModel) _then;

  @override
  $Res call({
    Object? blockNumber = freezed,
    Object? time = freezed,
    Object? blockHash = freezed,
    Object? reward = freezed,
    Object? percentage = freezed,
    Object? personalLuck = freezed,
    Object? isImmature = freezed,
    Object? isUncle = freezed,
    Object? isOrphan = freezed,
    Object? isSolo = freezed,
  }) {
    return _then(_value.copyWith(
      blockNumber: blockNumber == freezed
          ? _value.blockNumber
          : blockNumber // ignore: cast_nullable_to_non_nullable
              as int,
      time: time == freezed
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as DateTime,
      blockHash: blockHash == freezed
          ? _value.blockHash
          : blockHash // ignore: cast_nullable_to_non_nullable
              as String,
      reward: reward == freezed
          ? _value.reward
          : reward // ignore: cast_nullable_to_non_nullable
              as double,
      percentage: percentage == freezed
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      personalLuck: personalLuck == freezed
          ? _value.personalLuck
          : personalLuck // ignore: cast_nullable_to_non_nullable
              as double,
      isImmature: isImmature == freezed
          ? _value.isImmature
          : isImmature // ignore: cast_nullable_to_non_nullable
              as bool,
      isUncle: isUncle == freezed
          ? _value.isUncle
          : isUncle // ignore: cast_nullable_to_non_nullable
              as bool,
      isOrphan: isOrphan == freezed
          ? _value.isOrphan
          : isOrphan // ignore: cast_nullable_to_non_nullable
              as bool,
      isSolo: isSolo == freezed
          ? _value.isSolo
          : isSolo // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$RewardModelCopyWith<$Res>
    implements $RewardModelCopyWith<$Res> {
  factory _$RewardModelCopyWith(
          _RewardModel value, $Res Function(_RewardModel) then) =
      __$RewardModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {int blockNumber,
      DateTime time,
      String blockHash,
      double reward,
      double percentage,
      double personalLuck,
      bool isImmature,
      bool isUncle,
      bool isOrphan,
      bool isSolo});
}

/// @nodoc
class __$RewardModelCopyWithImpl<$Res> extends _$RewardModelCopyWithImpl<$Res>
    implements _$RewardModelCopyWith<$Res> {
  __$RewardModelCopyWithImpl(
      _RewardModel _value, $Res Function(_RewardModel) _then)
      : super(_value, (v) => _then(v as _RewardModel));

  @override
  _RewardModel get _value => super._value as _RewardModel;

  @override
  $Res call({
    Object? blockNumber = freezed,
    Object? time = freezed,
    Object? blockHash = freezed,
    Object? reward = freezed,
    Object? percentage = freezed,
    Object? personalLuck = freezed,
    Object? isImmature = freezed,
    Object? isUncle = freezed,
    Object? isOrphan = freezed,
    Object? isSolo = freezed,
  }) {
    return _then(_RewardModel(
      blockNumber: blockNumber == freezed
          ? _value.blockNumber
          : blockNumber // ignore: cast_nullable_to_non_nullable
              as int,
      time: time == freezed
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as DateTime,
      blockHash: blockHash == freezed
          ? _value.blockHash
          : blockHash // ignore: cast_nullable_to_non_nullable
              as String,
      reward: reward == freezed
          ? _value.reward
          : reward // ignore: cast_nullable_to_non_nullable
              as double,
      percentage: percentage == freezed
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      personalLuck: personalLuck == freezed
          ? _value.personalLuck
          : personalLuck // ignore: cast_nullable_to_non_nullable
              as double,
      isImmature: isImmature == freezed
          ? _value.isImmature
          : isImmature // ignore: cast_nullable_to_non_nullable
              as bool,
      isUncle: isUncle == freezed
          ? _value.isUncle
          : isUncle // ignore: cast_nullable_to_non_nullable
              as bool,
      isOrphan: isOrphan == freezed
          ? _value.isOrphan
          : isOrphan // ignore: cast_nullable_to_non_nullable
              as bool,
      isSolo: isSolo == freezed
          ? _value.isSolo
          : isSolo // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_RewardModel implements _RewardModel {
  const _$_RewardModel(
      {required this.blockNumber,
      required this.time,
      required this.blockHash,
      required this.reward,
      required this.percentage,
      required this.personalLuck,
      required this.isImmature,
      required this.isUncle,
      required this.isOrphan,
      required this.isSolo});

  @override
  final int blockNumber;
  @override
  final DateTime time;
  @override
  final String blockHash;
  @override
  final double reward;
  @override
  final double percentage;
  @override
  final double personalLuck;
  @override
  final bool isImmature;
  @override
  final bool isUncle;
  @override
  final bool isOrphan;
  @override
  final bool isSolo;

  @override
  String toString() {
    return 'RewardModel(blockNumber: $blockNumber, time: $time, blockHash: $blockHash, reward: $reward, percentage: $percentage, personalLuck: $personalLuck, isImmature: $isImmature, isUncle: $isUncle, isOrphan: $isOrphan, isSolo: $isSolo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RewardModel &&
            const DeepCollectionEquality()
                .equals(other.blockNumber, blockNumber) &&
            const DeepCollectionEquality().equals(other.time, time) &&
            const DeepCollectionEquality().equals(other.blockHash, blockHash) &&
            const DeepCollectionEquality().equals(other.reward, reward) &&
            const DeepCollectionEquality()
                .equals(other.percentage, percentage) &&
            const DeepCollectionEquality()
                .equals(other.personalLuck, personalLuck) &&
            const DeepCollectionEquality()
                .equals(other.isImmature, isImmature) &&
            const DeepCollectionEquality().equals(other.isUncle, isUncle) &&
            const DeepCollectionEquality().equals(other.isOrphan, isOrphan) &&
            const DeepCollectionEquality().equals(other.isSolo, isSolo));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(blockNumber),
      const DeepCollectionEquality().hash(time),
      const DeepCollectionEquality().hash(blockHash),
      const DeepCollectionEquality().hash(reward),
      const DeepCollectionEquality().hash(percentage),
      const DeepCollectionEquality().hash(personalLuck),
      const DeepCollectionEquality().hash(isImmature),
      const DeepCollectionEquality().hash(isUncle),
      const DeepCollectionEquality().hash(isOrphan),
      const DeepCollectionEquality().hash(isSolo));

  @JsonKey(ignore: true)
  @override
  _$RewardModelCopyWith<_RewardModel> get copyWith =>
      __$RewardModelCopyWithImpl<_RewardModel>(this, _$identity);
}

abstract class _RewardModel implements RewardModel {
  const factory _RewardModel(
      {required int blockNumber,
      required DateTime time,
      required String blockHash,
      required double reward,
      required double percentage,
      required double personalLuck,
      required bool isImmature,
      required bool isUncle,
      required bool isOrphan,
      required bool isSolo}) = _$_RewardModel;

  @override
  int get blockNumber;
  @override
  DateTime get time;
  @override
  String get blockHash;
  @override
  double get reward;
  @override
  double get percentage;
  @override
  double get personalLuck;
  @override
  bool get isImmature;
  @override
  bool get isUncle;
  @override
  bool get isOrphan;
  @override
  bool get isSolo;
  @override
  @JsonKey(ignore: true)
  _$RewardModelCopyWith<_RewardModel> get copyWith =>
      throw _privateConstructorUsedError;
}
